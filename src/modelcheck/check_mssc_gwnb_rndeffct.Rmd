---
title: "Check MSSC: modeling individual effect in variance"
author: Songpeng Zu
date: "`r format(Sys.time(), '%d %B %Y')`"
urlcolor: blue
fontsize: 12pt
output:
  html_document
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  cache = TRUE, warning = FALSE,
  message = FALSE, cache.lazy = FALSE,
  collapse = TRUE, comment = "##"
)
```

# Set R environment
```{r cache=TRUE}
## Set R environment
import::from(here, here)
suppressPackageStartupMessages(library(tidyverse))
library(MCMCpack)
library(cmdstanr)

## use the code below to reload the library
## detach("package:cmdstanr", unload = TRUE)
## library(cmdstanr)

library(bayesplot)
## for bayesplot plotting
## color_scheme_set("brewer-Spectral")

library(posterior)
library(bbmle)
library(sads)

## local modules
options("import.path" = here("rutils"))
myt <- modules::import("transform")
myfit <- modules::import("myfitdistr")
## use the code below to reload the modules
## modules::reload(myfit)
mypseudo <- modules::import("pseudobulk")
mypbmc <- modules::import("pbmc")

## warnings/errors traceback settings
options(error = traceback)
options(warn = 0)
options(mc.cores = 3)
set.seed(355113)
``` 

# load pbmc for parameter estimate and setting.
## Classical genes as DE
   - SNHG16, OASL, NAMPT, NFKB1, BCL2L11, TRAF4, ICAM1, XCL2, XCL1, CCL3L3, CCL3L1

## Strong individual effect genes
   - HBA1, HBA2, HBD

## possible non-DE
   - TOX, YIPF5, CCL3, KDM6A, HDDC2

```{r cache= TRUE}
cell_type <- "Naive CD4+ T"
num_of_cell_per_ind <- 280
num_of_ind <- 10
num_of_ind_per_cond <- 5
num_of_cond <- 2

# a DE gene: DE one gene
d1g <- "NFKB1"

## the whole dataset
pbmc_seurat <- mypbmc$load_pbmc_seurat() %>%
  mypbmc$extract_from_seurat(pbmc_seurat = .)
## limit to the cell type
subscdata <- mypbmc$get_celltype_specific_scdata(
  pbmc_seurat$cnt,
  pbmc_seurat$resp,
  pbmc_seurat$inds,
  pbmc_seurat$ct,
  cell_type
)

## ** sample cell numbers
sample_cells <- mypbmc$sample_cells_per_ind(
  subscdata$inds,
  num_of_cell_per_ind
)
## note individual order is changed according to sample_cells
cnt <- subscdata$cnt[, sample_cells]
inds <- subscdata$inds[sample_cells]
resp <- subscdata$resp[sample_cells]
colsumcnt <- colSums(cnt)

## ** limit to one DE gene
d1g_cnt <- cnt[d1g, ]
outliers <- myfit$is_outlier(d1g_cnt)
d1g_cnt <- d1g_cnt[!outliers]
d1g_inds <- inds[!outliers]
d1g_resp <- resp[!outliers]
d1g_sumcnt <- colsumcnt[!outliers]

par(mfrow = c(1, 2))
hist(d1g_cnt[resp == 1])
hist(d1g_cnt[resp == 0])

## fit NB dist
d1g_fitted_mu <- get_fitted_mu(
  d1g_cnt,
  d1g_resp,
  d1g_inds,
  d1g_sumcnt
)

d1g_fitted_mu <- myfit$fit_gwnb_s2_till_cond_level(
  y = d1g_cnt,
  y_control = d1g_cnt[d1g_resp == 0],
  y_case = d1g_cnt[d1g_resp == 1],
  scale_of_s = median(d1g_sumcnt)
)
## show the values
d1g_fitted_mu
## -------
## fit NB for a list of genes, add see the distribution
## of the dispersion.
## -------
```

# Stan model: random effect
In this model, we integrate out the individual effects. In this way, the $\mu |
(\mu_0, \mu_{cond})
\sim \mathcal{N}(\mu_0 + \mu_{cond}, \sigma_{ind})$.

## load the stan script.
```{r gwnb_rndeffect, cache=TRUE}
sbc_gwnb_rndeff_model <- cmdstan_model(
  here::here("src", "dirty_stan", "gwnb_rndeffect.stan"),
  compile = T
)
sbc_gwnb_rndeff_model$print()
```

## estimate the hyper parameters from the known dataset
```{r hyper_from_pbmc, cache=TRUE}
vec_of_cond <- c(
  rep(1, num_of_cell_per_ind * num_of_ind_per_cond),
  rep(2, num_of_cell_per_ind * num_of_ind_per_cond)
)
vec_of_ind_under_cond <- c(
  paste0(
    "NR",
    rep(
      seq_len(num_of_ind_per_cond),
      num_of_cell_per_ind
    )
  ),
  paste0("R", rep(seq_len(num_of_ind_per_cond), num_of_cell_per_ind))
)

vec_of_ind <- c(vapply(seq_len(num_of_ind),
  FUN = function(x) {
    rep(x, num_of_cell_per_ind)
  },
  FUN.VALUE = c(rep(0.0, num_of_cell_per_ind))
))

## for muInd
## This can be estimated based on other genes
alphaKappa2G <- 1.0
## based on inv-gamma mode = beta/(alpha + 1)
## betaKappa2G <- (alphaKappa2G + 1) * var(d1g_fitted_mu$mu_ind)
betaKappa2G <- 1.0

## for MuCond
## This can be estimated based on other genes.
alphaTau2G <- 1.0
## betaTau2G <- (alphaTau2G + 1) * var(d1g_fitted_mu$mu_cond)
betaTau2G <- 1.0

## for muG
## muG0 <- d1g_fitted_mu$mu0
muG0 <- -7.0
## This can be estiamted based on other genes.
sigmaG0 <- 2.0

## for NB dispersion
## This needs other genes' information.
alphaPhi2G <- 1.0
betaPhi2G <- (alphaPhi2G + 1) * d1g_fitted_mu$r0
```

## Sampling from the prior after setting the hyper parameters.
```{r cache=TRUE}
mug <- muG0
kappa2g <- rinvgamma(1,
  shape = alphaKappa2G,
  scale = betaKappa2G
)
tau2g <- rinvgamma(1,
  shape = alphaTau2G,
  scale = betaTau2G
)
phi2g <- rinvgamma(1,
  shape = alphaPhi2G,
  scale = betaPhi2G
)

## set.seed(1)
## muind <- rnorm(num_of_ind,
##   mean = 0.0,
##   sd = sqrt(kappa2g)
## )
mucond <- rnorm(num_of_cond,
  mean = 0.0,
  sd = sqrt(tau2g)
)

y <- vapply(seq_len(num_of_cell_per_ind * num_of_ind),
  FUN = function(i) {
    logmu <- rnorm(1,
      mean = mug + mucond[vec_of_cond[i]],
      sd = sqrt(kappa2g)
    )
    rnbinom(
      n = 1,
      mu = d1g_sumcnt[i] * exp(logmu),
      size = phi2g
    )
  },
  FUN.VALUE = 0.0
)
## print the values
mug
kappa2g
tau2g
phi2g
## muind
mucond
str(y)

## Set the initial values
sbc_mu_list <- myfit$fit_gwnb_s2_till_cond_level(
                       y = y,
                       y_control = y[vec_of_cond == 1],
                       y_case = y[vec_of_cond == 2],
                       scale_of_s = median(d1g_sumcnt)
                     )


## kappa2g <- var(sbc_mu_list$mu_ind)
kappa2g <- 1.0
tau2g <- var(sbc_mu_list$mu_cond)
phi2g <- sbc_mu_list$r0

## Finally set the initial values for the parameters
N <- num_of_cell_per_ind * num_of_ind
init_params <- list(
  MuG = sbc_mu_list$mu0,
  MuRaw = rnorm(n = N, mean = 0, sd = 0.01),
  MuCondRaw = sbc_mu_list$mu_cond / sqrt(tau2g),
  Kappa2G = kappa2g,
  Tau2G = tau2g,
  Phi2G = phi2g
)
## print the values
str(init_params)
```

```{r cache=TRUE}
## Finally set the data for mssc.
mydata <- list(
  N = num_of_cell_per_ind * num_of_ind,
  K = num_of_ind,
  J = num_of_cond,
  S = d1g_sumcnt,
  Cond = vec_of_cond,
  y = y,
  muG0 = muG0,
  sigmaG0 = sigmaG0,
  alphaKappa2G = alphaKappa2G,
  betaKappa2G = betaKappa2G,
  alphaTau2G = alphaTau2G,
  betaTau2G = betaTau2G,
  alphaPhi2G = alphaPhi2G,
  betaPhi2G = betaPhi2G
)
```

## use the estimated values as initials
```{r cache=TRUE}
sbc_vi_sampler <- sbc_gwnb_rndeff_model$variational(
  data = mydata,
  seed = 355113,
  refresh = 10,
  output_samples = 1000,
  iter = 1000,
  eval_elbo = 10,
  adapt_engaged = TRUE,
  init = list(init_params)
)
```

### Results with initial values
```{r cache=TRUE}
sbc_vi_draws <- sbc_vi_sampler$draws()

bayesplot::mcmc_hist(sbc_vi_draws, pars = c("MuG"))
bayesplot::mcmc_hist(sbc_vi_draws,
  regex_pars = c("MuCond\\[")
)

bayesplot::mcmc_hist(sbc_vi_draws,
  regex_pars = c("Kappa2G")
)
bayesplot::mcmc_hist(sbc_vi_draws,
  regex_pars = c("Tau2G")
)
bayesplot::mcmc_hist(sbc_vi_draws,
  regex_pars = c("Phi2G")
)
```


